<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>1 Big O Notation | Interviewgator</title>
  <meta name="description" content="1 Big O Notation | Interviewgator" />
  <meta name="generator" content="bookdown 0.20 and GitBook 2.6.7" />

  <meta property="og:title" content="1 Big O Notation | Interviewgator" />
  <meta property="og:type" content="book" />
  
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="1 Big O Notation | Interviewgator" />
  
  
  




  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="index.html"/>
<link rel="next" href="how-to-solve-coding-problems.html"/>
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />












<link rel="stylesheet" href="styles.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Preface</a><ul>
<li class="chapter" data-level="0.1" data-path="index.html"><a href="index.html#acknowledgement"><i class="fa fa-check"></i><b>0.1</b> Acknowledgement</a></li>
<li class="chapter" data-level="0.2" data-path="index.html"><a href="index.html#print"><i class="fa fa-check"></i><b>0.2</b> Print</a></li>
<li class="chapter" data-level="0.3" data-path="index.html"><a href="index.html#repository"><i class="fa fa-check"></i><b>0.3</b> Repository</a></li>
</ul></li>
<li class="chapter" data-level="1" data-path="big-o-notation.html"><a href="big-o-notation.html"><i class="fa fa-check"></i><b>1</b> Big O Notation</a><ul>
<li class="chapter" data-level="1.1" data-path="big-o-notation.html"><a href="big-o-notation.html#time-complexity"><i class="fa fa-check"></i><b>1.1</b> Time Complexity</a><ul>
<li class="chapter" data-level="1.1.1" data-path="big-o-notation.html"><a href="big-o-notation.html#on---linear-time"><i class="fa fa-check"></i><b>1.1.1</b> O(n) - Linear Time</a></li>
<li class="chapter" data-level="1.1.2" data-path="big-o-notation.html"><a href="big-o-notation.html#o1---constant-time"><i class="fa fa-check"></i><b>1.1.2</b> O(1) - Constant Time</a></li>
<li class="chapter" data-level="1.1.3" data-path="big-o-notation.html"><a href="big-o-notation.html#on2---quadratic-time"><i class="fa fa-check"></i><b>1.1.3</b> O(n^2) - Quadratic Time</a></li>
<li class="chapter" data-level="1.1.4" data-path="big-o-notation.html"><a href="big-o-notation.html#on---factorial-time"><i class="fa fa-check"></i><b>1.1.4</b> O(n!) - Factorial Time</a></li>
</ul></li>
<li class="chapter" data-level="1.2" data-path="big-o-notation.html"><a href="big-o-notation.html#space-complexity"><i class="fa fa-check"></i><b>1.2</b> Space Complexity</a><ul>
<li class="chapter" data-level="1.2.1" data-path="big-o-notation.html"><a href="big-o-notation.html#o1---constant-space"><i class="fa fa-check"></i><b>1.2.1</b> O(1) - Constant Space</a></li>
<li class="chapter" data-level="1.2.2" data-path="big-o-notation.html"><a href="big-o-notation.html#on---linear-space"><i class="fa fa-check"></i><b>1.2.2</b> O(n) - Linear Space</a></li>
</ul></li>
<li class="chapter" data-level="1.3" data-path="big-o-notation.html"><a href="big-o-notation.html#big-o-simplification"><i class="fa fa-check"></i><b>1.3</b> Big O Simplification</a><ul>
<li class="chapter" data-level="1.3.1" data-path="big-o-notation.html"><a href="big-o-notation.html#rule-1-worst-case"><i class="fa fa-check"></i><b>1.3.1</b> Rule 1: Worst Case</a></li>
<li class="chapter" data-level="1.3.2" data-path="big-o-notation.html"><a href="big-o-notation.html#rule-2-remove-constants"><i class="fa fa-check"></i><b>1.3.2</b> Rule 2: Remove Constants</a></li>
<li class="chapter" data-level="1.3.3" data-path="big-o-notation.html"><a href="big-o-notation.html#rule-3-different-terms-for-inputs"><i class="fa fa-check"></i><b>1.3.3</b> Rule 3: Different Terms For Inputs</a></li>
<li class="chapter" data-level="1.3.4" data-path="big-o-notation.html"><a href="big-o-notation.html#rule-4-drop-non-dominants"><i class="fa fa-check"></i><b>1.3.4</b> Rule 4: Drop Non Dominants</a></li>
</ul></li>
<li class="chapter" data-level="1.4" data-path="big-o-notation.html"><a href="big-o-notation.html#big-o-cheat-sheet"><i class="fa fa-check"></i><b>1.4</b> Big O Cheat Sheet</a></li>
<li class="chapter" data-level="1.5" data-path="big-o-notation.html"><a href="big-o-notation.html#summary---big-o"><i class="fa fa-check"></i><b>1.5</b> Summary - Big O</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="how-to-solve-coding-problems.html"><a href="how-to-solve-coding-problems.html"><i class="fa fa-check"></i><b>2</b> How To Solve Coding Problems</a><ul>
<li class="chapter" data-level="2.1" data-path="how-to-solve-coding-problems.html"><a href="how-to-solve-coding-problems.html#what-are-companies-looking-for"><i class="fa fa-check"></i><b>2.1</b> What Are Companies Looking For?</a><ul>
<li class="chapter" data-level="2.1.1" data-path="how-to-solve-coding-problems.html"><a href="how-to-solve-coding-problems.html#analytic-skills"><i class="fa fa-check"></i><b>2.1.1</b> Analytic Skills</a></li>
<li class="chapter" data-level="2.1.2" data-path="how-to-solve-coding-problems.html"><a href="how-to-solve-coding-problems.html#coding-skills"><i class="fa fa-check"></i><b>2.1.2</b> Coding Skills</a></li>
<li class="chapter" data-level="2.1.3" data-path="how-to-solve-coding-problems.html"><a href="how-to-solve-coding-problems.html#technical-skills"><i class="fa fa-check"></i><b>2.1.3</b> Technical Skills</a></li>
<li class="chapter" data-level="2.1.4" data-path="how-to-solve-coding-problems.html"><a href="how-to-solve-coding-problems.html#communication-skills"><i class="fa fa-check"></i><b>2.1.4</b> Communication Skills</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="how-to-solve-coding-problems.html"><a href="how-to-solve-coding-problems.html#interview-at-google"><i class="fa fa-check"></i><b>2.2</b> Interview At Google</a></li>
<li class="chapter" data-level="2.3" data-path="how-to-solve-coding-problems.html"><a href="how-to-solve-coding-problems.html#coding-interview-cheat-sheet"><i class="fa fa-check"></i><b>2.3</b> Coding Interview Cheat Sheet</a></li>
<li class="chapter" data-level="2.4" data-path="how-to-solve-coding-problems.html"><a href="how-to-solve-coding-problems.html#summary---how-to-solve-coding-problems"><i class="fa fa-check"></i><b>2.4</b> Summary - How To Solve Coding Problems</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="data-structures.html"><a href="data-structures.html"><i class="fa fa-check"></i><b>3</b> Data Structures</a><ul>
<li class="chapter" data-level="3.1" data-path="data-structures.html"><a href="data-structures.html#what-is-a-data-structure"><i class="fa fa-check"></i><b>3.1</b> What Is A Data-Structure?</a><ul>
<li class="chapter" data-level="3.1.1" data-path="data-structures.html"><a href="data-structures.html#how-computers-store-data"><i class="fa fa-check"></i><b>3.1.1</b> How Computers Store Data</a></li>
<li class="chapter" data-level="3.1.2" data-path="data-structures.html"><a href="data-structures.html#why-is-this-important-for-data-structure"><i class="fa fa-check"></i><b>3.1.2</b> Why Is This Important For Data Structure?</a></li>
</ul></li>
<li class="chapter" data-level="3.2" data-path="data-structures.html"><a href="data-structures.html#array-data-structure"><i class="fa fa-check"></i><b>3.2</b> Array Data Structure</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="algorithms.html"><a href="algorithms.html"><i class="fa fa-check"></i><b>4</b> Algorithms</a></li>
<li class="chapter" data-level="5" data-path="non-technical.html"><a href="non-technical.html"><i class="fa fa-check"></i><b>5</b> Non Technical</a></li>
<li class="chapter" data-level="6" data-path="playground.html"><a href="playground.html"><i class="fa fa-check"></i><b>6</b> Playground</a></li>
<li class="chapter" data-level="7" data-path="resources.html"><a href="resources.html"><i class="fa fa-check"></i><b>7</b> Resources</a><ul>
<li class="chapter" data-level="7.1" data-path="resources.html"><a href="resources.html#mentioned-in-this-book"><i class="fa fa-check"></i><b>7.1</b> Mentioned in this book</a></li>
<li class="chapter" data-level="7.2" data-path="resources.html"><a href="resources.html#practice"><i class="fa fa-check"></i><b>7.2</b> Practice</a></li>
<li class="chapter" data-level="7.3" data-path="resources.html"><a href="resources.html#videos"><i class="fa fa-check"></i><b>7.3</b> Videos</a></li>
</ul></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Interviewgator</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="big-o-notation" class="section level1">
<h1><span class="header-section-number">1</span> Big O Notation</h1>
<p>What is good code? Good code is a code that is <strong>readable</strong> and <strong>scalable</strong>.</p>
<p>Readable means that the code is clean and easy to understand by yourself and other programers.</p>
<p>Scalable means that is it fast to execute and consumes as little memory as possible. The speed of execution is call <strong>Time Complexity</strong> and the memory consumption is called <strong>Space Complexity</strong>. Most programming solutions are usually a trade off between the two complexities: You want fast code? You may have to use more memory. You whant memory efficient code? You may have to give up some speed.</p>
<p>These three things (readability, speed and memory) are what is called: the <strong>three pillars of code</strong>.</p>
<p><code>Readability + Speed + Memory</code></p>
<p>The Big O Notation gives an idea of the scalability of our code. In other words, how efficient our code is.</p>
<p>The goal here is to plan long term. Even if you think your newest project will only have a hundred users, it is wise to plan for it to grow from the get go. Like it you won’t have to constantly tinker old code when your user base grows.</p>
<p>It is especially important in big tech companies because they manage a lot of data, and as the data increases, the execution speed of the code slows down and the memory usage increases. So it is very important to optimize the code to make sure it runs as fast &amp; light as possible.</p>
<p>But how can we mesure code efficiency?</p>
<div id="time-complexity" class="section level2">
<h2><span class="header-section-number">1.1</span> Time Complexity</h2>
<p>Here is what time complexity looks like on a Big O chart (Elements is the amount of data past to the function and Operations represent the efficiency of the function):</p>
<div class="figure">
<img src="assets/big-o-complexity-chart.jpeg" alt="Big O Complexity Chart from bigocheatsheet.com" />
<p class="caption">Big O Complexity Chart from <a href="https://www.bigocheatsheet.com/" target="_blank">bigocheatsheet.com</a></p>
</div>
<p>As we can see, the <code>O(1)</code> and <code>O(log n)</code> are the most performant functions and the <code>O(n!)</code>and <code>O(2^n)</code> are the least perfomant functions.</p>
<p>When calculating a Big O notation, we always give the worst possible performance for the function and simplify it’s notation. For more information please head to the <a href="big-o-notation.html#big-o-simplification">Big O Simplification</a> section.</p>
<div id="on---linear-time" class="section level3">
<h3><span class="header-section-number">1.1.1</span> O(n) - Linear Time</h3>
<p>This is probably the most common Big O notation. It simply means that when you have an input of <code>n</code> the function will perform <code>n</code> operations on it.</p>
<p>As the number of input increases, the number of operations increases in a linear fashion.</p>
<p>If you input an array of size 100, the function will perform 100 operations, if you input an array of 1000000 items, it will perform 1000000 operations!</p>
<p><strong>Example:</strong></p>
<pre><code>const bigArray = new Array(100).fill(0);

function loopArray(array) {
  for (let i = 0; i &lt; array.length; i++) {
    console.count(array[i]);
  }
}

loopArray(bigArray);</code></pre>
<div class="caption">
<p>
Try it out on <a href="https://repl.it/@RilDev/Big-O-Notation-On-Linear-Time" target="_blank">repl.it</a>!
</p>
</div>
</div>
<div id="o1---constant-time" class="section level3">
<h3><span class="header-section-number">1.1.2</span> O(1) - Constant Time</h3>
<p>Another very common Big O notation. It is the most efficient Big O there is! No matter the size of the input, the function will always perform only one operation.</p>
<p>The input could be an array of 1, 100 or 1000000 elements, the function will always do only 1 operation.</p>
<p><strong>Example:</strong></p>
<pre><code>const bigArray = new Array(100).fill(0);

function firstElement(array) {
  console.count(array[0])
}

firstElement(bigArray);</code></pre>
<div class="caption">
<p>
Try it out on <a href="https://repl.it/@RilDev/Big-O-Notation-O1-Constant-Time" target="_blan">repl.it</a>!
</p>
</div>
<p><strong>Note:</strong></p>
<p>If there are multiple operations in the O(1) function, we still write it O(1).</p>
<p>Because no matter how big the input is, the number of operation stills the same, the execution time is still constant. For more information please head to the <a href="big-o-notation.html#big-o-simplification">Big O Simplification</a> section.</p>
<pre><code>const bigArray = new Array(100).fill(0);

function firstTwoElements(array) {
  console.count(array[0]); //O(1)
  console.count(array[1]); //O(1)
  //... //O(1)
  //gives: O(1 + 1 + ...) = O(1)
}

firstTwoElements(bigArray);</code></pre>
<div class="caption">
<p>
Try it out on <a href="https://repl.it/@RilDev/O1-Constant-Time-2#index.js" target="_blan">repl.it</a>!
</p>
</div>
</div>
<div id="on2---quadratic-time" class="section level3">
<h3><span class="header-section-number">1.1.3</span> O(n^2) - Quadratic Time</h3>
<p>This is a very ineffective Big O. You should avoid it when possible.</p>
<p>Many interview question start with a <code>quadratic time</code> function and ask you to make it faster.</p>
<p>One common interview question that you might get is “Log all pairs of an array”.</p>
<p><strong>Example:</strong></p>
<pre><code>const array = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;];

function logAllPairsOfArray(input) {
  for (let i = 0; i &lt; input.length; i++) { //O(n)
    for (let j = 1; j &lt; input.length; j++) { //O(n)
      console.log(input[i], input[j]);
    }
  }
}

logAllPairsOfArray(array);

//gives: O(n*n) = O(n^2)</code></pre>
<div class="caption">
<p>
Try it out on <a href="https://repl.it/@RilDev/Big-O-Notation-On2-Quadratic-Time" target="_blank">repl.it</a>!
</p>
</div>
<p>Everytime an element is looped in the first for loop, the entire array is looped in the second for loop. So we multiply <code>n</code> by itself: <code>O(n*n)</code> = <code>O(n^2)</code> <em>(pronounced: O of n square)</em>.</p>
<p><strong>Note:</strong> If we had another loop within the two first loops, the Big O notation would have been <code>O(n*n*n)</code> = <code>O(n^3)</code>. But this is probably not something you would ever do!</p>
</div>
<div id="on---factorial-time" class="section level3">
<h3><span class="header-section-number">1.1.4</span> O(n!) - Factorial Time</h3>
<p>The worst possible Big O complexity there is. If you are writing one yourself, you are definitively doing something wrong.</p>
<p><strong>Example:</strong></p>
<pre><code>const input = 5;

function factorial(input) {
  for (let i = 0; i &lt; input; i++) {
    factorial(input - 1);
  }

  console.count(input);
}

factorial(input);</code></pre>
<div class="caption">
<p>
Try it out on <a href="https://repl.it/@RilDev/Big-O-Notation-On-Factorial-Time#index.js" target="_blank">repl.it</a>!
</p>
</div>
<p>This function is adding a nested loop for every input that we have. Never a good idea!</p>
</div>
</div>
<div id="space-complexity" class="section level2">
<h2><span class="header-section-number">1.2</span> Space Complexity</h2>
<p>Space complexity indicates how much memory the function will consume. Even thow computers now have a lot of RAM (Random Access Memory), it is not infinite!</p>
<div id="o1---constant-space" class="section level3">
<h3><span class="header-section-number">1.2.1</span> O(1) - Constant Space</h3>
<p>When we talk about space complexity, we only count additional space used by the function, because it is what we have control over. So we don’t include the input.</p>
<p><strong>Example:</strong></p>
<pre><code>let input = 10; //the input does not count in the space complexity

function constantSpace(input) {
  for (let i = 0; i &lt; input; i++) { //let i = 0 =&gt; O(1)
    console.log(i);
  }
}

constantSpace(input);

//gives: O(1)</code></pre>
<div class="caption">
<p>
Try it out on <a href="https://repl.it/@RilDev/Big-O-Notation-O1-Constant-Space#index.js" target="_blank">repl.it</a>!
</p>
</div>
<p>In this function, we only create the <code>let i = 0</code> variable, so this function is of space complexity of <code>O(1)</code>.</p>
</div>
<div id="on---linear-space" class="section level3">
<h3><span class="header-section-number">1.2.2</span> O(n) - Linear Space</h3>
<p>Now let’s say we want to populate an array in our function and return it, this gives us a time complexity of <code>O(n)</code>.</p>
<p><strong>Example:</strong></p>
<pre><code>const input = 10; //we do not count the inputs

function linearSpace(input) {
  const array = []; //O(1)

  for (let i = 0; i &lt; input; i++) { //O(1)
    array[i] = i; //O(n), because we create new memory space at every loop
  }

  return array;
}

linearSpace(input);

//gives: O(1 + 1 + n) = O(n)</code></pre>
<div class="caption">
<p>
Try it out on <a href="https://repl.it/@RilDev/Big-O-Notation-O1-Linear-Space" target="_blank">repl.it</a>!
</p>
</div>
<p>Here we create two variables <code>array</code> and <code>i</code>. Then loop <code>n</code> times. At every iteration, we allocate a new memory space to our <code>array</code>. Which gives us a space complexity of <code>O(1 + 1 + n)</code> = <code>O(n)</code>.</p>
</div>
</div>
<div id="big-o-simplification" class="section level2">
<h2><span class="header-section-number">1.3</span> Big O Simplification</h2>
<p>Usually, when calculating the Big O of a function. We don’t go through the whole function adding every variable assignment, loops and so on, we give the general trend of the function when called with a big input.</p>
<p><strong>Example:</strong></p>
<pre><code>function complexBigONotation(input) {
  let a = 10; //O(1)
  a = 50 + 3; //O(1)

  for (let i = 0; i &lt; input.length; i++) { //O(n)
    anotherFunction(); //O(n)
    let extraBoolean = true; //O(n)
    a++; //O(n)
  }

  for (let i = 0; i &lt; input.length; i++) { //O(n)
    a++; //O(n)
  }

  return a; //O(1)
}

//gives: O(n + n + n + n + n + n + 1 + 1 + 1) = O(6n + 3) = O(6n) = O(n)</code></pre>
<p>This example function is actually an <code>O(n)</code> function.</p>
<p>Here is how we simplify a Big O notation.</p>
<div id="rule-1-worst-case" class="section level3">
<h3><span class="header-section-number">1.3.1</span> Rule 1: Worst Case</h3>
<p>When calculating Big O, we always asume that we are running the function in a worst case scenario. So if we have to loop through an input to look for a value we asume that we always have to loop through all the items in the input.</p>
<p><strong>Example:</strong></p>
<pre><code>const bigArray = new Array(100).fill(0);
bigArray.push(1);

function loopArray(array) {
  for (let i = 0; i &lt; array.length; i++) {
    console.count(array[i]);
    if (array[i] === 1) break;
  }
}

loopArray(bigArray);</code></pre>
<div class="caption">
<p>
Try it out on <a href="https://repl.it/@RilDev/Big-O-Simplification-Worst-Case#index.js" target="_blank">repl.it</a>!
</p>
</div>
<p>Functions with loops looping over the input <code>for (let i = 0; i &lt; input.length)</code> will always be at least <code>O(n)</code>.</p>
</div>
<div id="rule-2-remove-constants" class="section level3">
<h3><span class="header-section-number">1.3.2</span> Rule 2: Remove Constants</h3>
<p>When calculating the Big O notation of a function, we remove all the elements that would become unsignificant when feeding huge inputs to our function.</p>
<p><strong>Example:</strong></p>
<pre><code>const bigArray = new Array(100).fill(0);

function complexFunction(array) {
  console.log(array[0]); //O(1)

  for (let i = 0; i &lt; 10; i++) { //O(10)
    console.count(array[i]);
  }

  for (let i = 0; i &lt; Math.floor(array.length / 2); i++) { //O(n/2)
    console.count(array[i]);
  }

  for (let i = 0; i &lt; array.length; i++) { //O(n)
    console.count(array[i]);
  }

  for (let i = 0; i &lt; array.length; i++) { //O(n)
    console.count(array[i]);
  }
}

complexFunction(bigArray);


//gives: O(1 + 10 + n/2 + n + n) = O(2n + n/2 + 11) = O(2n + n/2) = O(2n + n) = O(3n) = O(n)</code></pre>
<div class="caption">
<p>
Try it out on <a href="https://repl.it/@RilDev/Big-O-Simplification-Remove-Constants#index.js" target="_blank">repl.it</a>!
</p>
</div>
<p>The function in the previous block gives us <code>O(2n + n/2 + 11)</code>.</p>
<ul>
<li><p>If we had an input of <code>10000</code> elements, the constant of <code>11</code> would be negligeable. So we remove it: <code>O(2n + n/2)</code></p></li>
<li><p>If we had an input of <code>10000000</code> elements, dividing by two has a decreasingly important effect. So we remove it: <code>O(2n + n)</code> = <code>O(3n)</code></p></li>
<li><p>And finally, because <code>O(n)</code> and <code>O(3n)</code> are both linear time Big O’s (the number of calculations increase linearly as the size of the input increases), we drop the multiplier: <code>O(n)</code></p></li>
</ul>
<p>Remember, Big O is about knowing the trend of a function when processing a lot of data. Therefore, if there are fixed operations that are always done by the function not matter the size of the input, we don’t include them in our calculation. The same way, if there are multiple calculations that are of the same type (like here, <code>linear time</code>) we reduce it the one of the Big O notations on the chart (so <code>O(3n)</code> becomes <code>O(n)</code>).</p>
</div>
<div id="rule-3-different-terms-for-inputs" class="section level3">
<h3><span class="header-section-number">1.3.3</span> Rule 3: Different Terms For Inputs</h3>
<p>When there are multiple inputs, you have to indicate it in the Big O notation.</p>
<p><strong>Example:</strong></p>
<pre><code>const bigArray1 = Array(100).fill(0);
const bigArray2 = Array(1000).fill(1);

function multipleInputs(array1, array2) {
  for (let i = 0; i &lt; array1.length; i++) { //O(n)
    console.count(array1[i]);
  }
  
  for (let i = 0; i &lt; array2.length; i++) { //O(m)
    console.count(array2[i]);
  }
}

multipleInputs(bigArray1, bigArray2);

//gives: O(n+m)
//NOT: O(2n) = O(n)</code></pre>
<div class="caption">
<p>
Try it out on <a href="https://repl.it/@RilDev/Big-O-Simplification-Different-Terms-For-Inputs#index.js" target="_blank">repl.it</a>!
</p>
</div>
<p>This function is <strong>NOT</strong> <code>O(n)</code> because there are multiple inputs that can be of a totally different sizes.</p>
<p>So the third rule of Big O precises that we have to diffrenciate those inputs in the Big O notation.</p>
<p>Here the notation is: <code>O(n+m)</code></p>
<p>What about nested loops with different arrays? <em>Glad you asked.</em> In that case, the notation will be <code>O(n*m)</code>.</p>
<p><strong>Example:</strong></p>
<pre><code>const bigArray1 = Array(10).fill(0);
const bigArray2 = Array(5).fill(1);

function multipleInputs(array1, array2) {
  for (let i = 0; i &lt; array1.length; i++) { //O(n)
    for (let j = 0; j &lt; array2.length; j++) { //(m)
      console.count(bigArray1[i]);
    }
  }
}

multipleInputs(bigArray1, bigArray2);

//gives: O(n*m)</code></pre>
<div class="caption">
<p>
Try it out on <a href="https://repl.it/@RilDev/Big-O-Simplification-Different-Terms-For-Inputs-2" target="_blank">repl.it</a>!
</p>
</div>
<p>Here the notation is <code>O(n*m)</code> because at every element in the first loop, all the elements of the second loop will be iterated over.</p>
<p>A good rule of thumb to differenciate <code>O(n+m)</code> and <code>O(n*m)</code> is: Every step that happens in the same indentation (one after another), you add <code>+</code>. And everything that happens with an indentation that is nested, you multiply <code>*</code>.</p>
</div>
<div id="rule-4-drop-non-dominants" class="section level3">
<h3><span class="header-section-number">1.3.4</span> Rule 4: Drop Non Dominants</h3>
<p>Since Big O notation is concerned with big inputs, we drop everything that would be insignificant when passing a lot of data to the function.</p>
<p><strong>Example:</strong></p>
<pre><code>const bigArray = Array(200).fill(0);

function complexBigO(array) {
  for (let i = 0; i &lt; 100; i++) { //O(100)
    console.count(array[i]);
  }

  for (let i = 0; i &lt; array.length; i++) { //O(n)
    console.count(array[i]);
  }

  for (let i = 0; i &lt; array.length; i++) { //O(n)
    for (let j = 0; j &lt; array.length; j++) { //O(n)
      console.count(array[i] + array[j]);
    }
  }
}

complexBigO(bigArray);

//gives: O(100 + n + n * n) = O(100 + n + n^2) = O(n + n^2) = O(n^2)</code></pre>
<div class="caption">
<p>
Try it out on <a href="https://repl.it/@RilDev/Big-O-Simplification-Drop-Non-Dominants#index.js" target="_blank">repl.it</a>!
</p>
</div>
<p>The function above has a Big O complexity of <code>O(100 + n + n^2)</code>.</p>
<p>Even with a relatively small input, like here with 200 elements, we quickly realize that the <code>O(n^2)</code> trumps all other complexities present:</p>
<ul>
<li>the <code>O(100)</code> will perform 100 operations</li>
<li>the <code>O(n)</code> will perform 200 operations</li>
<li>the <code>O(n^2)</code> will perform 40 000 operations!</li>
</ul>
<p>We can then simply remove the <code>O(100)</code> and <code>O(n)</code> since there impact on performance will be negligeable compared to the <code>O(n^2)</code> time complexity.</p>
</div>
</div>
<div id="big-o-cheat-sheet" class="section level2">
<h2><span class="header-section-number">1.4</span> Big O Cheat Sheet</h2>
<p>Andrei did a cheat sheet to remember all these things at a glance.</p>
<p>You can <a href="./assets/bigo-cheat-sheet.pdf" target="_blank">download it here</a>!</p>
<p>There is also this <a href="https://codility.com/media/train/1-TimeComplexity.pdf" target="_blank">time complexity lesson</a> by <a href="https://codility.com/" target="_blank">Codility</a> that I found useful.</p>
</div>
<div id="summary---big-o" class="section level2">
<h2><span class="header-section-number">1.5</span> Summary - Big O</h2>
<p>So good code is code that is <strong>readable</strong> and <strong>scalable</strong>.</p>
<p>Big O is a very important concept that you wont encounter on your day to day job but that you always have to keep in the back of your mind because computer resources are expenssive for the company your are going to be working for. Good developers and engineer always have this knowledge. That is why it is such a popular topic during interviews.</p>
<p>Remember, it’s all about trade-offs. Maybe readability will matter more than scalability in some cases. Or maybe time complexity will be less important than space complexity.</p>
<p>Do not optimize your code prematurly. Optimizing for time or space could negatively impact readability which would be less than ideal in a start-up environment for instance.</p>
<p>A great engineer knows how to strike the right balance between run time, space and redability. If for instance the data past to a function is always small, a linear time algorithm might be better than a constant time algorithm.</p>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="index.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="how-to-solve-coding-problems.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
}
});
});
</script>

</body>

</html>
