[
["index.html", "Interviewgator Preface 0.1 Acknowledgement 0.2 Print 0.3 Repository", " Interviewgator Preface Review and practice common data structures to prepare for your… interviewgation! 0.1 Acknowledgement In this book based on Andrei Neagoie’s Master the Coding Interview: Data Structures + Algorithms you will be able to learn/review common data structures, algorithms and interview techniques. PS: if you are looking for a job, you should totally checkout Andrei’s courses! 0.2 Print Coming soon… 0.3 Repository The code for this project is available at https://github.com/RilDev/interviewgator "],
["big-o-notation.html", "1 Big O Notation 1.1 O(n) - Linear Time 1.2 O(1) - Constant Time 1.3 O(n^2) - Quadratic Time 1.4 Big O Simplification 1.5 Cheat Sheet", " 1 Big O Notation What is good code? Good code is a code that is readable and scalable. The Big O Notation gives an idea of the scalability of our code. In other words, how efficient our code is. It is especially important in big tech companies because they manage a lot of data, and as the data increase, the execution speed of the code slows down. So it is very important to optimize the code to make sure it runs as fast as possible. But how can we mesure code efficiency? Here is what code efficiency looks like on a Big O chart (Elements is the amount of data past to the function and Operations represent the efficiency of the function): Big O Complexity Chart from bigocheatsheet.com As we can see, the O(1) and O(log n) are the most performant scripts and the O(n!)and O(2^n) are the least perfomant scripts. When calculating a Big O notation, we always give the worst possible performance for the script and simplify it’s notation. For more information please head to the Big O Simplification section. 1.1 O(n) - Linear Time This is probably the most common Big O notation. It simply means that when you have an input of n the function will perform n operations on it. As the number of input increases, the number of operations increases in a linear fashion. If you input an array of size 100, the function will perform 100 operations, if you input an array of 1000000 items, it will perform 1000000 operations! Example: const bigArray = new Array(100).fill(0); function loopArray(array) { for (let i = 0; i &lt; array.length; i++) { console.count(array[i]); } } loopArray(bigArray); Try it out on repl.it! 1.2 O(1) - Constant Time Another very common Big O notation. It is the most efficient Big O there is! No matter the size of the input, the function will always perform only one operation. The input could be an array of 1, 100 or 1000000 elements, the function will always do only 1 operation. Example: const bigArray = new Array(100).fill(0); function firstElement(array) { console.count(array[0]) } firstElement(bigArray); Try it out on repl.it! Note: If there are multiple operations in the O(1) function, we still write it O(1). Because no matter how big the input is, the number of operation stills the same, the execution time is still constant. const bigArray = new Array(100).fill(0); function firstTwoElements(array) { console.count(array[0]); //O(1) console.count(array[1]); //O(1) //... //O(1) //gives: O(1 + 1 + ...) = O(1) } firstTwoElements(bigArray); Try it out on repl.it! 1.3 O(n^2) - Quadratic Time This is a very ineffective Big O. You should avoid it when possible. Many interview question start with a quadratic time function and ask you to make it faster. One common interview question that you might get is “Log all pairs of an array”. Example: const array = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]; function logAllPairsOfArray(input) { for (let i = 0; i &lt; input.length; i++) { //O(n) for (let j = 1; j &lt; input.length; j++) { //O(n) console.log(input[i], input[j]); } } } logAllPairsOfArray(array); //gives: O(n*n) = O(n^2) Try it out on repl.it! Everytime an element is looped in the first for loop, the entire array is looped in the second for loop. So we multiply n by itself: O(n*n) = O(n^2) (pronounced: O of n square). 1.4 Big O Simplification Usually, when calculating the Big O of a function. We don’t go through the whole function adding every variable assignment, loops and so on, we give the general trend of the function when called with a big input. Example: function complexBigONotation(input) { let a = 10; //O(1) a = 50 + 3; //O(1) for (let i = 0; i &lt; input.length; i++) { //O(n) anotherFunction(); //O(n) let extraBoolean = true; //O(n) a++; //O(n) } for (let i = 0; i &lt; input.length; i++) { //O(n) a++; //O(n) } return a; //O(1) } //gives: O(n + n + n + n + n + n + 1 + 1 + 1) = O(6n + 3) = O(6n) = O(n) This example function is actually an O(n) function. Here is how we simplify a Big O notation. 1.4.1 Rule 1: Worst Case When calculating Big O, we always asume that we are running the function in a worst case scenario. So if we have to loop through an input to look for a value we asume that we always have to loop through all the intems in the input. Example: const bigArray = new Array(100).fill(0); bigArray.push(1); function loopArray(array) { for (let i = 0; i &lt; array.length; i++) { console.count(array[i]); if (array[i] === 1) break; } } loopArray(bigArray); Try it out on repl.it! Functions with loops looping over the input for (let i = 0; i &lt; input.length) will always be at least O(n). 1.4.2 Rule 2: Remove Constants When calculating the Big O notation of a function, we remove all the elements that would become unsignificant when feeding huge inputs to our function. Example: const bigArray = new Array(100).fill(0); function complexFunction(array) { console.log(array[0]); //O(1) for (let i = 0; i &lt; 10; i++) { //O(10) console.count(array[i]); } for (let i = 0; i &lt; Math.floor(array.length / 2); i++) { //O(n/2) console.count(array[i]); } for (let i = 0; i &lt; array.length; i++) { //O(n) console.count(array[i]); } for (let i = 0; i &lt; array.length; i++) { //O(n) console.count(array[i]); } } complexFunction(bigArray); //gives: O(1 + 10 + n/2 + n + n) = O(2n + n/2 + 11) = O(2n + n/2) = O(2n + n) = O(3n) = O(n) Try it out on repl.it! The function in the previous block gives us O(2n + n/2 + 11). If we had an input of 10000 elements, the constant of 11 would be negligeable. So we remove it: O(2n + n/2) If we had an input of 10000000 elements, dividing by two has a decreasingly important effect. So we remove it: O(2n + n) = O(3n) And finally, because O(n) and O(3n) are both linear time Big O’s (the number of calculations increase linearly as the size of the input increases), we drop the multiplier: O(n) Remember, Big O is about knowing the trend of a function when processing a lot of data. Therefore, if there are fixed operations that are always done by the function not matter the size of the input, we don’t include them in our calculation. The same way, if there are multiple calculations that are of the same type (like here, linear time) we reduce it the one of the Big O notations on the chart (so O(3n) becomes O(n)). 1.4.3 Rule 3: Different Terms For Inputs When there are multiple inputs, you have to indicate it in the Big O notation. Example: const bigArray1 = Array(100).fill(0); const bigArray2 = Array(1000).fill(1); function multipleInputs(array1, array2) { for (let i = 0; i &lt; array1.length; i++) { //O(n) console.count(array1[i]); } for (let i = 0; i &lt; array2.length; i++) { //O(m) console.count(array2[i]); } } multipleInputs(bigArray1, bigArray2); //gives: O(n+m) //NOT: O(2n) = O(n) Try it out on repl.it! This function is NOT O(n) because there are multiple inputs that can be of a totally different sizes. So the third rule of Big O precises that we have to diffrenciate those inputs in the Big O notation. Here the notation is: O(n+m) What about nested loops with different arrays? Glad you asked. In that case, the notation will be O(n*m). Example: const bigArray1 = Array(10).fill(0); const bigArray2 = Array(5).fill(1); function multipleInputs(array1, array2) { for (let i = 0; i &lt; array1.length; i++) { //O(n) for (let j = 0; j &lt; array2.length; j++) { //(m) console.count(bigArray1[i]); } } } multipleInputs(bigArray1, bigArray2); //gives: O(n*m) Try it out on repl.it! Here the notation is O(n*m) because at every element in the first loop, all the elements of the second loop will be iterated over. A good rule of thumb to differenciate O(n+m) and O(n*m) is: Every step that happens in the same indentation (one after another), you add +. And everything that happens with an indentation that is nested, you multiply *. 1.4.4 Rule 4: Drop Non Dominants Since Big O notation is concerned with big inputs, we drop everything that would be insignificant when passing a lot of data to the function. Example: const bigArray = Array(200).fill(0); function complexBigO(array) { for (let i = 0; i &lt; 100; i++) { //O(100) console.count(array[i]); } for (let i = 0; i &lt; array.length; i++) { //O(n) console.count(array[i]); } for (let i = 0; i &lt; array.length; i++) { //O(n) for (let j = 0; j &lt; array.length; j++) { //O(n) console.count(array[i] + array[j]); } } } complexBigO(bigArray); //gives: O(100 + n + n * n) = O(100 + n + n^2) = O(n + n^2) = O(n^2) Try it out on repl.it! The function above has a Big O complexity of O(100 + n + n^2). Even with a relatively small input, like here with 200 elements, we quickly realize that the O(n^2) trumps all other complexities present: the O(100) will perform 100 operations the O(n) will perform 200 operations the O(n^2) will perform 40 000 operations! We can then simply remove the O(100) and O(n) since there impact on performance will be negligeable compared to the O(n^2) time complexity. 1.5 Cheat Sheet Andrei did a cheat sheet to remember all these things at a glance. You can download it here! "],
["data-structures.html", "2 Data Structures", " 2 Data Structures "],
["algorithms.html", "3 Algorithms", " 3 Algorithms "],
["non-technical.html", "4 Non Technical", " 4 Non Technical "],
["playground.html", "5 Playground", " 5 Playground Coming Soon… This playground will be composed of 2 screens: one for inputs and one for the outputs. The input screen will have 2 tabs: one for defining functions and the other to specify inputs and expected results for every function. Every function may have multiple rows of inputs/expected results. The output screen will show all the results. For each function, all the inputs, outputs and expected results. As well as a counter to display: passing function count / total function call count. Here is a quick wireframe of what I’m talking about: Wireframe made with wireframe.cc Here is a little prototype made with Pico-8: Download Interviewgator.p8 Note: This is only a POC. At this time, you will need to have the Pico-8 devtool to run this game. It’s 15$. Sorry about that. I’ll be working on a fully featured JS playground (complitly free) when I have the time. "],
["resources.html", "6 Resources 6.1 Mentioned in this book 6.2 Practice", " 6 Resources 6.1 Mentioned in this book Master the Coding Interview: Data Structures + Algorithms: The online course this book is based upon https://github.com/RilDev/interviewgator: The repository where this book is stored repl.it: online coding environment bigocheatsheet.com: Big O notation graph and common data structures operations 6.2 Practice Codility: A platform used by many tech companies like TopTal to test people applying to them Hackerrank: Another platform that companies use to test developers "]
]
