[
["index.html", "Interviewgator Preface 0.1 Acknowledgement 0.2 Print 0.3 Repository", " Interviewgator Preface Review and practice common data structures to prepare for your… interviewgation! 0.1 Acknowledgement In this book based on Andrei Neagoie’s Master the Coding Interview: Data Structures + Algorithms you will be able to learn/review common data structures, algorithms and interview techniques. PS: if you are looking for a job, you should totally checkout Andrei’s courses! 0.2 Print Coming soon… 0.3 Repository The code for this project is available at https://github.com/RilDev/interviewgator "],
["big-o-notation.html", "1 Big O Notation 1.1 Time Complexity 1.2 Space Complexity 1.3 Big O Simplification 1.4 Big O Cheat Sheet 1.5 Summary - Big O", " 1 Big O Notation What is good code? Good code is a code that is readable and scalable. Readable means that the code is clean and easy to understand by yourself and other programers. Scalable means that is it fast to execute and consumes as little memory as possible. The speed of execution is call Time Complexity and the memory consumption is called Space Complexity. Most programming solutions are usually a trade off between the two complexities: You want fast code? You may have to use more memory. You whant memory efficient code? You may have to give up some speed. These three things (readability, speed and memory) are what is called: the three pillars of code. Readability + Speed + Memory The Big O Notation gives an idea of the scalability of our code. In other words, how efficient our code is. The goal here is to plan long term. Even if you think your newest project will only have a hundred users, it is wise to plan for it to grow from the get go. Like it you won’t have to constantly tinker old code when your user base grows. It is especially important in big tech companies because they manage a lot of data, and as the data increases, the execution speed of the code slows down and the memory usage increases. So it is very important to optimize the code to make sure it runs as fast &amp; light as possible. But how can we mesure code efficiency? 1.1 Time Complexity Here is what time complexity looks like on a Big O chart (Elements is the amount of data past to the function and Operations represent the efficiency of the function): Big O Complexity Chart from bigocheatsheet.com As we can see, the O(1) and O(log n) are the most performant functions and the O(n!)and O(2^n) are the least perfomant functions. When calculating a Big O notation, we always give the worst possible performance for the function and simplify it’s notation. For more information please head to the Big O Simplification section. 1.1.1 O(n) - Linear Time This is probably the most common Big O notation. It simply means that when you have an input of n the function will perform n operations on it. As the number of input increases, the number of operations increases in a linear fashion. If you input an array of size 100, the function will perform 100 operations, if you input an array of 1000000 items, it will perform 1000000 operations! Example: const bigArray = new Array(100).fill(0); function loopArray(array) { for (let i = 0; i &lt; array.length; i++) { console.count(array[i]); } } loopArray(bigArray); Try it out on repl.it! 1.1.2 O(1) - Constant Time Another very common Big O notation. It is the most efficient Big O there is! No matter the size of the input, the function will always perform only one operation. The input could be an array of 1, 100 or 1000000 elements, the function will always do only 1 operation. Example: const bigArray = new Array(100).fill(0); function firstElement(array) { console.count(array[0]) } firstElement(bigArray); Try it out on repl.it! Note: If there are multiple operations in the O(1) function, we still write it O(1). Because no matter how big the input is, the number of operation stills the same, the execution time is still constant. For more information please head to the Big O Simplification section. const bigArray = new Array(100).fill(0); function firstTwoElements(array) { console.count(array[0]); //O(1) console.count(array[1]); //O(1) //... //O(1) //gives: O(1 + 1 + ...) = O(1) } firstTwoElements(bigArray); Try it out on repl.it! 1.1.3 O(n^2) - Quadratic Time This is a very ineffective Big O. You should avoid it when possible. Many interview question start with a quadratic time function and ask you to make it faster. One common interview question that you might get is “Log all pairs of an array”. Example: const array = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]; function logAllPairsOfArray(input) { for (let i = 0; i &lt; input.length; i++) { //O(n) for (let j = 1; j &lt; input.length; j++) { //O(n) console.log(input[i], input[j]); } } } logAllPairsOfArray(array); //gives: O(n*n) = O(n^2) Try it out on repl.it! Everytime an element is looped in the first for loop, the entire array is looped in the second for loop. So we multiply n by itself: O(n*n) = O(n^2) (pronounced: O of n square). Note: If we had another loop within the two first loops, the Big O notation would have been O(n*n*n) = O(n^3). But this is probably not something you would ever do! 1.1.4 O(n!) - Factorial Time The worst possible Big O complexity there is. If you are writing one yourself, you are definitively doing something wrong. Example: const input = 5; function factorial(input) { for (let i = 0; i &lt; input; i++) { factorial(input - 1); } console.count(input); } factorial(input); Try it out on repl.it! This function is adding a nested loop for every input that we have. Never a good idea! 1.2 Space Complexity Space complexity indicates how much memory the function will consume. Even thow computers now have a lot of RAM (Random Access Memory), it is not infinite! 1.2.1 O(1) - Constant Space When we talk about space complexity, we only count additional space used by the function, because it is what we have control over. So we don’t include the input. Example: let input = 10; //the input does not count in the space complexity function constantSpace(input) { for (let i = 0; i &lt; input; i++) { //let i = 0 =&gt; O(1) console.log(i); } } constantSpace(input); //gives: O(1) Try it out on repl.it! In this function, we only create the let i = 0 variable, so this function is of space complexity of O(1). 1.2.2 O(n) - Linear Space Now let’s say we want to populate an array in our function and return it, this gives us a time complexity of O(n). Example: const input = 10; //we do not count the inputs function linearSpace(input) { const array = []; //O(1) for (let i = 0; i &lt; input; i++) { //O(1) array[i] = i; //O(n), because we create new memory space at every loop } return array; } linearSpace(input); //gives: O(1 + 1 + n) = O(n) Try it out on repl.it! Here we create two variables array and i. Then loop n times. At every iteration, we allocate a new memory space to our array. Which gives us a space complexity of O(1 + 1 + n) = O(n). 1.3 Big O Simplification Usually, when calculating the Big O of a function. We don’t go through the whole function adding every variable assignment, loops and so on, we give the general trend of the function when called with a big input. Example: function complexBigONotation(input) { let a = 10; //O(1) a = 50 + 3; //O(1) for (let i = 0; i &lt; input.length; i++) { //O(n) anotherFunction(); //O(n) let extraBoolean = true; //O(n) a++; //O(n) } for (let i = 0; i &lt; input.length; i++) { //O(n) a++; //O(n) } return a; //O(1) } //gives: O(n + n + n + n + n + n + 1 + 1 + 1) = O(6n + 3) = O(6n) = O(n) This example function is actually an O(n) function. Here is how we simplify a Big O notation. 1.3.1 Rule 1: Worst Case When calculating Big O, we always asume that we are running the function in a worst case scenario. So if we have to loop through an input to look for a value we asume that we always have to loop through all the items in the input. Example: const bigArray = new Array(100).fill(0); bigArray.push(1); function loopArray(array) { for (let i = 0; i &lt; array.length; i++) { console.count(array[i]); if (array[i] === 1) break; } } loopArray(bigArray); Try it out on repl.it! Functions with loops looping over the input for (let i = 0; i &lt; input.length) will always be at least O(n). 1.3.2 Rule 2: Remove Constants When calculating the Big O notation of a function, we remove all the elements that would become unsignificant when feeding huge inputs to our function. Example: const bigArray = new Array(100).fill(0); function complexFunction(array) { console.log(array[0]); //O(1) for (let i = 0; i &lt; 10; i++) { //O(10) console.count(array[i]); } for (let i = 0; i &lt; Math.floor(array.length / 2); i++) { //O(n/2) console.count(array[i]); } for (let i = 0; i &lt; array.length; i++) { //O(n) console.count(array[i]); } for (let i = 0; i &lt; array.length; i++) { //O(n) console.count(array[i]); } } complexFunction(bigArray); //gives: O(1 + 10 + n/2 + n + n) = O(2n + n/2 + 11) = O(2n + n/2) = O(2n + n) = O(3n) = O(n) Try it out on repl.it! The function in the previous block gives us O(2n + n/2 + 11). If we had an input of 10000 elements, the constant of 11 would be negligeable. So we remove it: O(2n + n/2) If we had an input of 10000000 elements, dividing by two has a decreasingly important effect. So we remove it: O(2n + n) = O(3n) And finally, because O(n) and O(3n) are both linear time Big O’s (the number of calculations increase linearly as the size of the input increases), we drop the multiplier: O(n) Remember, Big O is about knowing the trend of a function when processing a lot of data. Therefore, if there are fixed operations that are always done by the function not matter the size of the input, we don’t include them in our calculation. The same way, if there are multiple calculations that are of the same type (like here, linear time) we reduce it the one of the Big O notations on the chart (so O(3n) becomes O(n)). 1.3.3 Rule 3: Different Terms For Inputs When there are multiple inputs, you have to indicate it in the Big O notation. Example: const bigArray1 = Array(100).fill(0); const bigArray2 = Array(1000).fill(1); function multipleInputs(array1, array2) { for (let i = 0; i &lt; array1.length; i++) { //O(n) console.count(array1[i]); } for (let i = 0; i &lt; array2.length; i++) { //O(m) console.count(array2[i]); } } multipleInputs(bigArray1, bigArray2); //gives: O(n+m) //NOT: O(2n) = O(n) Try it out on repl.it! This function is NOT O(n) because there are multiple inputs that can be of a totally different sizes. So the third rule of Big O precises that we have to diffrenciate those inputs in the Big O notation. Here the notation is: O(n+m) What about nested loops with different arrays? Glad you asked. In that case, the notation will be O(n*m). Example: const bigArray1 = Array(10).fill(0); const bigArray2 = Array(5).fill(1); function multipleInputs(array1, array2) { for (let i = 0; i &lt; array1.length; i++) { //O(n) for (let j = 0; j &lt; array2.length; j++) { //(m) console.count(bigArray1[i]); } } } multipleInputs(bigArray1, bigArray2); //gives: O(n*m) Try it out on repl.it! Here the notation is O(n*m) because at every element in the first loop, all the elements of the second loop will be iterated over. A good rule of thumb to differenciate O(n+m) and O(n*m) is: Every step that happens in the same indentation (one after another), you add +. And everything that happens with an indentation that is nested, you multiply *. 1.3.4 Rule 4: Drop Non Dominants Since Big O notation is concerned with big inputs, we drop everything that would be insignificant when passing a lot of data to the function. Example: const bigArray = Array(200).fill(0); function complexBigO(array) { for (let i = 0; i &lt; 100; i++) { //O(100) console.count(array[i]); } for (let i = 0; i &lt; array.length; i++) { //O(n) console.count(array[i]); } for (let i = 0; i &lt; array.length; i++) { //O(n) for (let j = 0; j &lt; array.length; j++) { //O(n) console.count(array[i] + array[j]); } } } complexBigO(bigArray); //gives: O(100 + n + n * n) = O(100 + n + n^2) = O(n + n^2) = O(n^2) Try it out on repl.it! The function above has a Big O complexity of O(100 + n + n^2). Even with a relatively small input, like here with 200 elements, we quickly realize that the O(n^2) trumps all other complexities present: the O(100) will perform 100 operations the O(n) will perform 200 operations the O(n^2) will perform 40 000 operations! We can then simply remove the O(100) and O(n) since there impact on performance will be negligeable compared to the O(n^2) time complexity. 1.4 Big O Cheat Sheet Andrei did a cheat sheet to remember all these things at a glance. You can download it here! There is also this time complexity lesson by Codility that I found useful. 1.5 Summary - Big O So good code is code that is readable and scalable. Big O is a very important concept that you wont encounter on your day to day job but that you always have to keep in the back of your mind because computer resources are expenssive for the company your are going to be working for. Good developers and engineer always have this knowledge. That is why it is such a popular topic during interviews. Remember, it’s all about trade-offs. Maybe readability will matter more than scalability in some cases. Or maybe time complexity will be less important than space complexity. Do not optimize your code prematurly. Optimizing for time or space could negatively impact readability which would be less than ideal in a start-up environment for instance. A great engineer knows how to strike the right balance between run time, space and redability. If for instance the data past to a function is always small, a linear time algorithm might be better than a constant time algorithm. "],
["how-to-solve-coding-problems.html", "2 How To Solve Coding Problems 2.1 What Are Companies Looking For? 2.2 Interview At Google 2.3 Coding Interview Cheat Sheet 2.4 Summary - How To Solve Coding Problems", " 2 How To Solve Coding Problems The big question interviewers are trying to answer is: “Are you gonna solve their problems?”. Because if you are able to solve their problems, then you will bring in more money than you cost them. It’s not the smartest interviewee that will get hired most of the time but the one that can answer this question: “Will you solve our problems?”. If you are a genius but don’t work well with others, or you write ugly code that no one understands, or you can’t communicate a solution to a problem… then you wont get a job. You see, it’s not necesarely about the solution to a problem in the coding interview, it’s about the thought process and knowing the trade-offs between data-structure and algorithms: space and time complexity. Just like in real life coding, you don’t memorize things, you just have to deeply understand it. In this section we are going to see what is the ideal process to ace the interview, so that once we have this fundation we can use data-structure and algorithms to solve these problems. Because an interview is not about memorizing data-structures and algorithms, but knowing them! The interviewer will be able to make the difference right away. 2.1 What Are Companies Looking For? Most people get hang up on the idea of learning every algorithms out there, data-structures, doing a thousand coding problems to practice before an interview. And these are important but in most companies you wont have to know how to write a binary search stream or write sorting algorithms from scratch. That’s the type of thing you will learn on the job. And let’s be honest, no engineer has everything memorized, most of the time, when a problem presents itself, engineers will search the web. And companies know this. So they want people who know how to get the answers. They want to see if you know about data-structues and algorithms. They want to see if you know when to use one data-structure over the other, or why you should use an algorithm instead of another. Companies want smart people that can solve problems that they can’t solve themselves. That’s what they will be paying you for. Why are we doing things this way? Is so important to understand! It is very hard to find people who can solve problems on their own without holding their hand! Here are the four main things recruters will be looking at to see if you are a good fit for their company. 2.1.1 Analytic Skills Analytic skills is “How can you think trough a problem and analyse things?”. When you are coding for an interview they want to hear your thought process and go from not knowing the answer to solving the problem. 2.1.2 Coding Skills Do you code well? Is you code clean and well organized? Readable? 2.1.3 Technical Skills Do you know what you are doing? Do you know the pros and cons of the solution you are implementing or did you just memorize stuff? 2.1.4 Communication Skills You communication skill go from your personality (does your personality match the company’s personality?) to how you communicate with your team. You probably wont work by yourself, but you will have to communicate with your team, managers, bosses and they want to know if you are going to be able to fit well. 2.2 Interview At Google Here is an example of an excellent interview at Google. You may not understand everything the first time around, but by the end of this book, it should become second nature to you! Again, you should definitly check Andrei’s course to fast track your progess! 2.3 Coding Interview Cheat Sheet Andrei did a cheat sheet to recap all the things you have to think about during a coding interview. You can download it here! 2.4 Summary - How To Solve Coding Problems A common misconception is that you either are a good problem solver or you arn’t. But as with anything it’s a muscle that you can train. So with enough practice and knowing the tips and tricks that we covered in this section, you can solve problems a lot better and show the interviewer that you know what you are talking about. The key in this section was the cheatsheet and the step by step walk through of a problem. We saw how a good Google interview would go. Think out loud and try to comment these steps as you go along. Communicating thoughout the process as much as possible and not trying to solve a problem fast is the key to interviewing and solving problems in an interview. You should not memorize problems. Because if you do a hundred problems it won’t help you long term. And you will be taking a gamble: hoping that the interviewer will ask you a question that you’ve seen before. If you practice the this in this course, you will be ready for anything. "],
["data-structures.html", "3 Data Structures 3.1 What Is A Data-Structure? 3.2 Array Data Structure", " 3 Data Structures In computer programming, data structures are the different ways available to the programmer to store data. Some are very common, others less so. They all have specific strengths and weaknesses when it comes to access data, insert data, delete data, search the data structure… We are going to explore the ones you are going to meet the most often during your developer journey. Remember, at the end of the day, programs are simply data structures and algorithms. Data Structures + Algorithms = Program And great programmers know how to pick the right data structure with the right algorithms to write good programs. Programs that are readable and scalable. No matter if you are a web developer or a game developer or anything in between, once you understand data-structure and algorithms, you will be able to use them to solve all kind of technical problems. That’s why companies like Google, Facebook and Amazon ask questions on data-structures and algorithms, because although it may be important to know the latest and greatest Javascript syntax or library, those things change. If you know the fondamentals though, you will be able to make the right decision in any situation. This is why this knowledge is so valuable. 3.1 What Is A Data-Structure? A data-structure is a collection of values. The values can have relations among them and functions applied to them. Each one is diffrent in what it can do and what it is useful for. Each data-structure is good / specialized for it’s own thing. Data-structure are like containers such as a back-pack, a fridge or a folder, each has its specialty: the back-pack for books, the fridge for food and the folder for documents. There are two parts to a data-structure: How to build one How to use it The goal of this chapter is to understand data-structure so that you can pick the right one for the job. 3.1.1 How Computers Store Data In order to understand the value of data-structures, we have to go deep down into the way computers work at a fundamental level. In order for a computer to run code, you have to keep track of things like variables (numbers, strings, arrays). The variables are store in the Random Access Memory (RAM). That’s how programs run. On top of that, we have storage to store our video files, music files, documents… that storage in contrast with the RAM is persistant. When we shut down our computer, those files stay on the drive. So why not only use persistant storage to run programs? The problem with persistant storage is that it is slow. A computer is run by the Central Processing Unit (CPU), it is the part doing all the calcualtions that we need. The CPU needs access to the RAM and the storage. But it can access the information in the RAM a lot faster. When we use a software, the CPU holds all the variables it needs to run the software in the RAM. And when it saves something in the program, it stores permanently some information in the storage. Like it, next time we turn on the computer, our files will still be here. A RAM is like a massive shelf, that holds data. Each of these shelves is composed of 8 bits. A bit is either on of off, 1 or 0. A series of 8 bits is called a byte. So each shelves in RAM is composed of 1 byte. The RAM has a memory controller that allows the CPU to access any byte very fast. Keep in mind that the memory controller will access bytes that are closed together faster. In addition, the CPU has a tiny cache to speed up even more memory access. 3.1.2 Why Is This Important For Data Structure? Data structures are ways for us to store information. For example, with a var a = 1, the integer 1 is stored in the RAM as a 32 or 64 (for more recent systems) bit informantion. A data structure is a way to manage data in the RAM. Some are organized close to each other, some are organized far from each other. And each one has different pros and cons when accessing and writing to the RAM. We are now going to learn more about data structures with this low level knowledge of how computers work. Each language may have different data types (numbers, strings, booleans…) and data structures (arrays, objects…) to organize these data types. Does it mean that we have to stick to the data structures available in a perticular language? Not really, we can create new data structures from existing ones! 3.2 Array Data Structure Arrays organize items sequentially, that means one after another in memory. They are probably the simplest and most widely used data structure. Arrays have the least amount of rules. And because they are stores sequentially in memory, they also have the smallest footprint of all data structures. If all you need is to store data and to iterate over it, arrays are the best choice. Especially if you know the indexes of the items stored. 3.2.1 Array’s Big O lookup push insert delete O(1) O(1) O(n) O(n) Example: const strings = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]; // the strings array occupies 4 bytes for each letter =&gt; 4 bytes * 4 = 16 bytes in memory // lookup: O(1) // to see what is the value at the demanded index console.log(&#39;lookup strings[2]: &#39; + strings[2]); // lookups in arrays are constant time, O(1), because the computer already knows where the 3rd item is going to be since the array is squentially stored in memory. // push: O(1) // add an item at the end of the array strings.push(&#39;e&#39;); console.log(`strings.push(&#39;e&#39;): ${strings}`); // pushes are constant time, O(1), because the new item is simply added at the end of the array in memory, without looping over anything. // pop: O(1) // remove an item from the end of the array strings.pop(); console.log(`strings.pop(): ${strings}`); // popes are also constant time, O(1), because we simply remove the last item, without looping through anything. // unshift: O(n) // add an item at the begining of the array strings.unshift(&#39;z&#39;); console.log(`strings.unshift(&#39;z&#39;): ${strings}`); // unshiftes are linear time, O(n), because when we add an item at the begining, we then have to loop through all the items to reasign the indexes to all the values that have been displaced. // splice: O(n) // in this example, we will use splice to insert an item at the desired index strings.splice(2, 0, &#39;n&#39;); console.log(`strings.splice(2, 0, &#39;n&#39;): ${strings}`); // splices are linear time, O(n), because we have to reassign the indexes that appear after the spliced part of the array by looping through them. We write it O(n) because we always plan for the worst case senario when using Big O notation. Try it out on repl.it! So arrays are really good for lookups and pushes. But not so good for inserting and deleting in an other place than at the end of the array. 3.2.2 Static VS Dynamic Arrays There are two types of arrays: static arrays and dynamic arrays. What is the difference between the two? Static Arrays: are fixed in size. You need to know the number of elements your array will hold ahead of time. Because arrays are allocated in adjacent blocks of memory when they are created there is no guaranty that after allocating a certain number of items in memory that you can keep on adding things on. Especially in order. So we solve this problem with static arrays by telling ahead of time how many shelves of memory we want to allocate to it. Dynamic Arrays: are expandable in size. If needed, the array can be automatically expanded by copying it to a new location in memory with double it original size. For example, if we wanted to add an eighth item to a seven items array, that array would be copied to another location in memory with 14 shelves of memory and the eighth item would be added to it. When dynamic arrays add a new item that exceeds their current size, they loop through all the items in the array to copy them to a new place in memory with usually two times more space in memory than the original array. Because of this, the Big O of dynamic arrays is as follow: lookup append* insert delete O(1) O(1) O(n) O(n) *can be O(n) Note: in Big O notation tables, append is the same a push Low level languages like C++ let us use static arrays that we have to manually manage, while higher level languages like Java, Python or JavaScript use dynamic arrays. It is a trade of: speed for convinence. Low level languages allow us to tweak things to make them much faster, but it is harder to manage. Most of the time during interviews, you will be working with dynamic arrays. But it is important to understand things at a fundamental level. For instance, now you know that to push an item in an array is O(1), but that once in a while, it can be an O(n) operation. 3.2.3 How To Build An Array Following is a basic array implementation: class CustomArray { // constructor: length and data constructor() { this.length = 0; this.data = {}; } // get: return value at specific index get(index) { return this.data[index]; } // push: append item at the end of the array push(item) { // add item at the end of the array this.data[this.length] = item; // increase length property this.length++; // return updated length property return this.length; } // pop: remove array&#39;s last element pop() { // copy last item const lastItem = this.data[this.length - 1]; // delete last item delete this.data[this.length - 1]; // decrease length this.length--; // return last item&#39;s copy return lastItem; } // delete: delete an item at specified index delete(index) { // copy index to delete const deletedItem = this.data[index] // shift elements from index to delete this.shiftItemsIndex(index); // remove last element delete this.data[this.length - 1]; // return deleted item return deletedItem; } // shift items&#39; indexes to the left to remove item at specified index shiftItemsIndex(index) { // loop from index to the end of the array, // attribute to each index the value of the next item for (let i = index; i &lt; this.length; i++) { this.data[i] = this.data[i + 1]; } } } // create new array const newArray = new CustomArray(); // log the array console.log(&#39;created array:&#39;); console.log(newArray); console.log(&#39;---&#39;) // push items to the array newArray.push(1); newArray.push(2); newArray.push(3); newArray.push(4); newArray.push(5); newArray.push(6); newArray.push(7); // log push result console.log(&#39;push to array:&#39;); console.log(newArray); console.log(&#39;---&#39;) // pop items from array newArray.pop(); newArray.pop(); newArray.pop(); // log pop result console.log(&#39;pop from array:&#39;); console.log(newArray); console.log(&#39;---&#39;) // delete items from array newArray.delete(2); // log delete result console.log(&#39;delete from array:&#39;); console.log(newArray); console.log(&#39;---&#39;) // get item in array console.log(&#39;get item in array:&#39;); console.log(newArray.get(1)); Try it out on repl.it! Note: Array in JavaScript are objects. Note: String questions should be treated as array questions.You can use a method like split to convert it to an array and then retrun it as a string. 3.2.4 How To Use An Array The following are common interview questions. 3.2.4.1 Reverse A String // Reverse a string // input: string // output: string reversed // checks: no input, too many inputs, input not a string, input less than 2 characters, large input // errors: no input, too many inputs, not a string // efficiency: O(n) // notes: none function reverseString(string) { // errors // no input or too many input if (arguments.length !== 1) { throw Error(&#39;Function takes exactly 1 input of type string.&#39;) } // input not a string if (typeof string !== &#39;string&#39;) { throw Error(&#39;Input must be of type string.&#39;) } // checks // string length &lt; 2, no need to loop if (string.length &lt; 2) { return string; } // reverse string // create reversed string variable let reversedString = &#39;&#39;; // loop through the string backward and push current value to reversed string for (let i = string.length - 1; i &gt;= 0; i--) { reversedString+= string[i]; } // return reversed string return reversedString; } // test the function // basic console.log(reverseString(&#39;Hello World!&#39;)); // empty string console.log(reverseString(&#39;&#39;)); // small string console.log(reverseString(&#39;a&#39;)); console.log(reverseString(&#39;ab&#39;)); console.log(reverseString(&#39;abc&#39;)); // large string console.log(reverseString(&#39;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce finibus, massa in fermentum posuere, erat ligula molestie mi, sed auctor enim lacus varius eros. Vestibulum consequat iaculis cursus. Donec quam massa, consectetur sed quam sed, consectetur feugiat enim. Cras nibh massa, cursus et tellus ac, euismod sagittis lacus. In malesuada, nunc id finibus pretium, ligula velit hendrerit metus, vitae tincidunt erat diam pellentesque ante. Suspendisse dictum purus nunc, ac vehicula lectus luctus vitae. Proin euismod urna a eleifend gravida. Praesent ornare elementum diam quis accumsan. Vivamus volutpat metus a odio efficitur tempus. Phasellus blandit dapibus neque nec viverra. Pellentesque ut lacus quis orci viverra volutpat. Maecenas eleifend iaculis ligula a imperdiet. Nam a ornare nisi. Pellentesque cursus, massa at facilisis elementum, neque lacus euismod massa, quis ultrices elit massa in tellus.&#39;)) //errors, uncomment 1 by 1 to see the error messages // no input // console.log(reverseString()); // input not of type string // console.log(reverseString(123)); // more than 1 input // console.log(reverseString(&#39;test1&#39;, &#39;test2&#39;)); // input is a boolean // console.log(reverseString(true)); // input is an object // console.log(reverseString({})); // input is an array // console.log(reverseString([])); Try it out on repl.it! "],
["algorithms.html", "4 Algorithms", " 4 Algorithms Coming Soon… "],
["non-technical.html", "5 Non Technical", " 5 Non Technical Coming Soon… "],
["playground.html", "6 Playground", " 6 Playground Coming Soon… This playground will be composed of 2 screens: one for inputs and one for the outputs. The input screen will have 2 tabs: one for defining functions and the other to specify inputs and expected results for every function. Every function may have multiple rows of inputs/expected results. The output screen will show all the results. For each function, all the inputs, outputs and expected results. As well as a counter to display: passing function count / total function call count. Here is a quick wireframe of what I’m talking about: Wireframe made with wireframe.cc Here is a little prototype made with Pico-8: Download Interviewgator.p8 Note: This is only a POC. At this time, you will need to have the Pico-8 devtool to run this game. It’s 15$. Sorry about that. I’ll be working on a fully featured JS playground (complitly free) when I have the time. "],
["resources.html", "7 Resources 7.1 Mentioned in this book 7.2 Practice 7.3 Videos", " 7 Resources 7.1 Mentioned in this book Master the Coding Interview: Data Structures + Algorithms: The online course this book is based upon https://github.com/RilDev/interviewgator: The repository where this book is stored repl.it: online coding environment bigocheatsheet.com: Big O notation graph and common data structures operations Codility’s time complexity lesson: a well put together lesson about Big O’s time and space complexity 7.2 Practice Codility: A platform used by many tech companies like TopTal to test people applying to them Hackerrank: Another platform that companies use to test developers 7.3 Videos Interview At Google: A example of how white board interviews play-out at Google. "]
]
